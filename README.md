<div align="center">

# Tech Challenge - API

![GitHub Release Date](https://img.shields.io/badge/Release%20Date-Dezembro%202024-yellowgreen)
![](https://img.shields.io/badge/Status-Em%20Desenvolvimento-yellowgreen)
<br>
![](https://img.shields.io/badge/Version-%20v3.0.0-brightgreen)
</div>

## üíª Descri√ß√£o

Este monolito √© respons√°vel por gerenciar a entrada de pedidos de um restaurante. Ele lida com o processamento dos
pedidos, gerenciamento de pagamentos e envio dos pedidos para a cozinha ap√≥s a confirma√ß√£o do pagamento.

## üõ† Tecnologias Utilizadas

<div align="center">

![Java](https://img.shields.io/badge/java_21-%23ED8B00.svg?style=for-the-badge&logo=openjdk&logoColor=white)
![Spring](https://img.shields.io/badge/spring_3-%236DB33F.svg?style=for-the-badge&logo=springboot&logoColor=white)
![Maven](https://img.shields.io/badge/Apache%20Maven-C71A36.svg?style=for-the-badge&logo=Apache-Maven&logoColor=white)
![Postgres](https://img.shields.io/badge/PostgreSQL-4169E1.svg?style=for-the-badge&logo=PostgreSQL&logoColor=white)
![Swagger](https://img.shields.io/badge/-Swagger-%23Clojure?style=for-the-badge&logo=swagger&logoColor=white)
![Docker](https://img.shields.io/badge/Docker-2496ED?style=for-the-badge&logo=docker&logoColor=white)
![Mercado Pago](https://img.shields.io/badge/Mercado%20Pago-00B1EA.svg?style=for-the-badge&logo=Mercado-Pago&logoColor=white)


</div>

## üí´ Arquitetura

O projeto segue a Clean Architecture, permitindo maior flexibilidade e facilidade de manuten√ß√£o.

### Desenho da arquitetura

![Desenho de Arquitetura](./assets/diagrams/DiagramaDeArquitetura.drawio.png)

### Diagramas sequenciais

<details style="cursor: pointer;">
 <summary style="background-color: #086dd7b0; border-radius: 5px; font-size: 15px; padding-left: 6px; font-weight: bold;">Diagrama sequencial de customers </summary>
 <br>
 
 ![Cadastro do Customer](./assets/diagrams/DiagramaDeSequenciaCustomers.drawio.png)

</details>

<details style="cursor: pointer;">
 <summary style="background-color: #086dd7b0; border-radius: 5px; font-size: 15px; padding-left: 6px; font-weight: bold;">Diagrama sequencial de products </summary>
 <br>
 
 ![Cadastro e listagem de produtos](./assets/diagrams/DiagramaDeSequenciaProdutos.drawio.png)

</details>

<details style="cursor: pointer;">
 <summary style="background-color: #086dd7b0; border-radius: 5px; font-size: 15px; padding-left: 6px; font-weight: bold;">Diagrama sequencial de orders </summary>
 <br>
 
 ![Cria√ß√£o de pedidos](./assets/diagrams/DiagramaDeSequenciaCriacaoPedido.drawio.png)
 ![Listagem de pedidos](./assets/diagrams/DiagramaDeSequenciaConsultarPedidos.drawio.png)

</details>

## ‚öôÔ∏è Configura√ß√£o

### Pr√©-requisitos

#### Desenvolvimento

- **[Java 21](https://docs.oracle.com/en/java/javase/21/)**: Documenta√ß√£o oficial do Java 21.
- **[Maven 3.6.3+](https://maven.apache.org/)**: Site oficial do Maven.
- **[Docker](https://www.docker.com/)**: Site oficial do Docker.
- **[Docker Compose](https://docs.docker.com/compose/)**: Documenta√ß√£o oficial do Docker Compose.
- **[Mercado Pago](https://www.mercadopago.com.br/developers/pt/docs/qr-code/integration-configuration/qr-dynamic/integration)**: Documenta√ß√£o oficial do Mercado Pago.

### üê≥ Imagem Docker

A imagem docker desse projeto foi buildada atrav√©s do arquivo `Dockerfile` presente neste reposit√≥rio.

### üöÄ Execu√ß√£o

<details style="cursor: pointer;">
 <summary style="background-color: #086dd7b0; border-radius: 5px; font-size: 15px; padding-left: 6px; font-weight: bold;">Subindo aplica√ß√£o via Docker Compose</summary>
<br>
Este projeto conta com um arquivo `docker-compose.yml` que pode ser utilizado para subir o container da aplica√ß√£o e suas
respectivas depend√™ncias (banco de dados).

Para subir as aplica√ß√µes, primeiro se faz necess√°ria a exist√™ncia de um arquivo `.env` na raiz do projeto, para que as
vari√°veis de ambiente sejam definidas. Esse projeto j√° conta com um arquivo versionado nesse reposit√≥rio, para que a
defini√ß√£o das vari√°veis n√£o precise ser feita. Abaixo segue a estrutura desse arquivo:

```sh
POSTGRES_URL=<url_do_banco_de_dados>
POSTGRES_DB=<nome_do_banco_de_dados>
POSTGRES_USERNAME=<usu√°rio_do_banco_de_dados>
POSTGRES_PASSWORD=<senha_do_usu√°rio_no_banco_de_dados>
```

Ap√≥s se certificar que o arquivo `.env` existe e est√° definindo as vari√°veis citadas acima, basta executar o
comando `docker compose up` para iniciar o build da imagem da aplica√ß√£o (Definida no arquivo `Dockerfile`) e realizar a
inicializa√ß√£o do container do banco de dados (Postgres) seguido pelo container da aplica√ß√£o.

Caso tudo d√™ certo, as seguintes linhas de log devem ter sido exibidas no terminal cujo comando foi executado:

- Pull da imagem do postgres:

![Pull da imagem do Postgres](./assets/pull_postgress_image.png)

- Build da imagem da aplica√ß√£o utilizando o conte√∫do do Dockerfile:

![Build da aplica√ß√£o via Dockerfile](./assets/build_app_docker_image.png)

- Criando volume e containers:

![Criando volumes e containers](./assets/creating_volume_and_containers.png)

- Container do postgres de p√© e rodando com sucesso

![Container do postgres de p√©](./assets/postgress_container_up.png)

- Container da aplica√ß√£o de p√© e rodando com sucesso

![Container da aplica√ß√£o de p√©](./assets/application_started.png)

Ap√≥s todos esses passos, basta rodar o comando `docker container ls` para verificar quais containers est√£o sendo
executados. Caso tudo tenha corrido com sucesso, o comando deve ter o seguinte resultado:

![Listagem de containers em execu√ß√£o](./assets/docker_container_ls.png)

Por fim, o servi√ßo estar√° dispon√≠vel em `http://localhost:8357` com contextPath `/api`

Obs: Caso queira subir os containers no modo `detached`(Sem travar o terminal em que o comando for executado), basta
rodar o seguinte comando: `docker compose up -d`

![Docker compose detached mode](./assets/compose_detached_mode.png)
</details>

### üõí Integra√ß√£o Checkout (Mercado Pago)

Nesta fase do projeto, integramos o Checkout com a API do Mercado Pago, possibilitando o pagamento via QR Code din√¢mico.

Para que o QR Code seja criado, deve-se primeiro criar um pedido (POST) no endpoint `/api/v1/orders`. Ap√≥s a execu√ß√£o desse endpoint, uma chamada interna ser√° feita para a API do Mercado Pago (POST) no endpoint `https://api.mercadopago.com/instore/orders/qr/seller/collectors/{user_id}/pos/{external_pos_id}/qrs` para gerar o QR Code. Com a string do QR gerada, o pagamento poder√° ser realizado. Ap√≥s a confirma√ß√£o do pagamento ou a ocorr√™ncia de uma falha, receberemos uma requisi√ß√£o no nosso webhook (POST) `/api/v1/webhook-payment`.

Exemplo do recebimento do webhook mandado pelo Mercado Pago: 
```bash
{
  "action": "payment.updated",
  "api_version": "v1",
  "data": {
    "id": "123456"
  },
  "date_created": "2021-11-01T02:02:02Z",
  "id": "123456",
  "live_mode": false,
  "type": "payment",
  "user_id": 1986357239
}
```
Em seguida, uma requisi√ß√£o ser√° feita internamente para o endpoint (GET) `https://api.mercadopago.com/v1/payments/{id}` do Mercado Pago para verificar o status do pagamento. Se o status for `approved`, alteraremos o status do pedido na nossa aplica√ß√£o para `PREPARING`.

Caso ocorram falhas e o pagamento n√£o seja efetivado dentro do intervalo de meia hora desde a cria√ß√£o do pedido, o pagamento n√£o poder√° ser realizado devido ao tempo de expira√ß√£o, e o pedido ser√° atualizado automaticamente para `FINISHED`. Isso ser√° feito pelo nosso `Scheduled`, que buscar√° todos os pedidos com status `RECEIVED` criados h√° mais de meia hora e os atualizar√° para o status `FINISHED`.

Observa√ß√£o: Deve-se considerar que nossa integra√ß√£o est√° sendo feita com o uso das contas de teste criadas no Mercado Pago.

### üìÑ Documenta√ß√£o da API

Link para acessar ao swagger ap√≥s subir a aplica√ß√£o:

```bash
# Ambiente Local via docker compose
http://localhost:8357/api/swagger-ui/index.html
```

üîó Ou acesse https://fiap-soat-12.github.io/fiap-soat-tech-challenge-api/

### üîÉ Ordem de execu√ß√£o das APIs

1. O primeiro passo, que √© opcional, seria realizar a cria√ß√£o de um novo usu√°rio (cadasto de usu√°rio) utilizando o endpoint (POST) `/api/v1/customers`
2. Ap√≥s o cadastro do usu√°rio, o pr√≥ximo passo, que tamb√©m √© opcional (pois nossa aplica√ß√£o j√° fornece `seeds` no banco de dados, com produtos pr√©-cadastrados), seria realizar o cadastro de um novo produto atrav√©s do endpoint (POST) `/api/v1/products`
3. O pr√≥ximo passo √© realizar a listagem de todos os produtos por categoria atrav√©s do endpoint (GET) `/api/v1/products`, para saber quais est√£o dispon√≠veis
4. Com os produtos escolhidos em m√£os, o pr√≥ximo passo √© realizar a cria√ß√£o de um pedido atrav√©s do endpoint (POST) `/api/v1/orders`, e salvar o c√≥digo do QRCode retornado no response, para realizar o pagamento do mesmo posteriormente
5. Ap√≥s realizar a cria√ß√£o do pedido, √© poss√≠vel verificar se o mesmo foi criado atrav√©s do endpoint (GET) `/api/v1/orders`. O mesmo deve estar listado no response dentro do status `received`
6. O pr√≥ximo passo ser√° realizar o pagamento do pedido criado. Para realizar o pagamento do pedido, basta ler o QRCode gerado no passo 4 (Para realizar a leitura do mesmo, √© necess√°rio utilizar um site que transforma a string Pix em uma imagem QRCode, como por exemplo o [https://www.qrcode-monkey.com/](https://www.qrcode-monkey.com/)) e realizar o pagamento atrav√©s do aplicativo do mercado pago (Pois a aplica√ß√£o est√° integrada ao gateway de pagamentos do mercado pago)
7. Ap√≥s ter efetuado o pagamento do pedido, √© poss√≠vel verificar se o mesmo foi realmente pago realizando uma chamada ao endpoint (GET) `/api/v1/orders/{id}/paid-status`.
8. Tamb√©m √© poss√≠vel verificar que o status do pedido foi atualizado para `preparing` chamando novamente o endpoint (GET) `/api/v1/orders`;
9. Para simular que a prepara√ß√£o do pedido foi finalizada pela cozinha, e que o pedido est√° pronto para ser retirado pelo cliente, basta chamar o endpoint (PATCH) `/api/v1/orders/{id}`
10. Ap√≥s isso, √© poss√≠vel verificar que o status do pedido foi atualizado para `ready` chamando novamente o endpoint (GET) `/api/v1/orders`;
11. Finalizando a esteira de entrega do pedido, √© poss√≠vel simular o ato de retirada do mesmo pelo cliente, realizando uma nova chamada ao endpoint (PATCH) `/api/v1/orders/{id}`
12. E como √∫ltimo passo, √© poss√≠vel verificar novamente o status do pedido utilizando o endpoint (GET) `/api/v1/orders`. Neste caso, como o pedido foi atualizado para o status `finished`, o mesmo n√£o deve mais estar sendo exibido no retorno do endpoint chamado.

Al√©m dos endpoints listados acima, existem outros que n√£o fazem parte do fluxo padr√£o da aplica√ß√£o, mas que podem ser utilizados:
1. √â poss√≠vel realizar uma chamada ao endpoint (PUT) `/api/v1/products/{id}` para realizar a atualiza√ß√£o de um produto qualquer (Que j√° tenha sido criado)
2. √â poss√≠vel realizar uma chamada ao endpoint (DELETE) `/api/v1/products/{id}` para realizar a exclus√£o de um produto qualquer (Que exista)
3. Existe um endpoint que n√£o √© chamado diretamente pelo cliente, que √© o `/api/v1/webhook-payment`. Este endpoint √© respons√°vel por receber a resposta do gateway de pagamentos, relacioada a a√ß√£o de pagamento do pedido (Pagamento realizado, ou falha no pagamento)
4. Caso queira, √© poss√≠vel verificar se o usu√°rio foi cadastrado e tamb√©m ver o detalhamento das informa√ß√µes do usu√°rio atrav√©s do endpoint (GET) `/api/v1/customers/{document}`

### üé≤ Seeds

Para facilitar o consumo e os testes da aplica√ß√£o, seeds de dados foram criadas e gerenciadas utilizando o `Flyway`. 
Essas seeds s√£o aplicadas automaticamente ao iniciar a aplica√ß√£o, garantindo um ambiente consistente e pronto para uso.

### üìö MIRO - Event Storming

![Event Storming](./assets/event_storming.png)

Acesso ao MIRO com o Event Storming:
[Event Storming](https://miro.com/app/board/uXjVK1ekBDM=/)
